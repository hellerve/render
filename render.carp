(load "Vector.carp")

(load "https://github.com/carpentry-org/file@0.0.5")

(defmodule Double
  (register MAX Double "DBL_MAX")
  (register MIN Double "DBL_MIN")
)

(deftype Color [
  inner (Vector3 Int)
])

(defmodule Color
  (defn rgb [r g b]
    (init (Vector3.init r g b)))

  (defn red [c]
    @(Vector3.x (inner c)))

  (defn green [c]
    @(Vector3.y (inner c)))

  (defn blue [c]
    @(Vector3.z (inner c)))

  (defn add [a b]
    (init (Vector3.add (inner a) (inner b))))

  (defn mul [c x]
    (init (Vector3.map (fn [e] (to-int (* (from-int e) x))) (inner c))))
)

(deftype Sphere [
  center (Vector3 Double)
  radius Double
  color Color
  specular Double
])

(deftype Light
  (Ambient [Double])
  (Point [Double (Vector3 Double)])
  (Directional [Double (Vector3 Double)])
)

(deftype Raytracer [
  spheres (Array Sphere)
  lights (Array Light)
  background-color Color
])

(defmodule Raytracer
  (def d 1.0)
  (def o (Vector3.init 0.0 0.0 0.0))
  (def inf Double.MAX)

  (defn canvas-to-viewport [x y w h]
    (Vector3.init (/ (from-int x) (from-int w)) (/ (from-int y) (from-int h)) d))

  (defn intersect-ray-sphere [o d sphere]
    (let [c (Sphere.center sphere)
          r @(Sphere.radius sphere)
          oc (Vector3.sub o c)

          k1 (Vector3.dot d d)
          k2 (* 2.0 (Vector3.dot &oc d))
          k3 (- (Vector3.dot &oc &oc) (* r r))

          discriminant (- (* k2 k2) (* 4.0 (* k1 k3)))]
      (if (< discriminant 0.0)
        (Pair.init inf inf)
        (let [t1 (/ (+ (neg k2) (sqrt discriminant)) (* 2.0 k1))
              t2 (/ (- (neg k2) (sqrt discriminant)) (* 2.0 k1))]
          (Pair.init t1 t2)))))

  (deftype IntersectionResult [
    closest Double
    closest-sphere (Maybe Sphere)
  ])

  (defn closest-intersection [scene o d tmin tmax]
    (let-do [closest inf
             closest-sphere (Maybe.Nothing)]
      (foreach [sphere (spheres scene)]
        (let [t (intersect-ray-sphere o d sphere)
              t1 @(Pair.a &t)
              t2 @(Pair.b &t)]
          (cond
            (and (between t2 tmin tmax) (< t2 closest))
              (do
                (set! closest t2)
                (set! closest-sphere (Maybe.Just @sphere)))
            (and (between t1 tmin tmax) (< t1 closest))
              (do
                (set! closest t1)
                (set! closest-sphere (Maybe.Just @sphere)))
            ())))
      (IntersectionResult.init closest closest-sphere)))

  (defn new-i [scene p l n i v s tmax]
    (let [ir (closest-intersection scene p l 0.001 tmax)]
      (if (Maybe.just? (IntersectionResult.closest-sphere &ir))
        0.0
        (let [ndl (Vector3.dot n l)]
          (+
            (if (> ndl 0.0)
              (/ (* i ndl) (* (Vector3.mag n) (Vector3.mag l)))
              0.0)
            (if (/= s -1.0)
              (let [r (Vector3.sub &(Vector3.mul &(Vector3.mul n (Vector3.dot n l)) 2.0) l)
                    rdv (Vector3.dot &r v)]
                (if (> rdv 0.0)
                  (* i (Double.pow (/ rdv (* (Vector3.mag &r) (Vector3.mag v))) s))
                  0.0))
              0.0))))))

  (defn lighting [scene p n v s tmax]
    (Array.reduce &(fn [i light]
      (+ i
        (match @light
          (Light.Ambient intensity) intensity
          (Light.Point intensity position)
            (new-i scene p &(Vector3.sub &position p) n intensity v s tmax)
          (Light.Directional intensity direction)
            (new-i scene p &direction n intensity v s tmax))))
      0.0 (lights scene)))

  (defn trace-ray [scene o d tmin tmax]
    (let-do [r (closest-intersection scene o d tmin tmax)
             closest @(IntersectionResult.closest &r)
             closest-sphere @(IntersectionResult.closest-sphere &r)]
      (let [p (Vector3.add o &(Vector3.mul d closest))
            n (Vector3.sub &p
                  &(Maybe.from (Maybe.apply @&closest-sphere (fn [c] @(Sphere.center &c))) @o))]
        (Maybe.from
          (Maybe.apply closest-sphere (fn [c]
            (Color.mul
              (Sphere.color &c)
              (lighting scene &p &(Vector3.div &n (Vector3.mag &n)) &(Vector3.neg d) @(Sphere.specular &c) tmax))))
          @(background-color scene)))))

  (defn trace [scene name w h]
    (let [f (Result.unsafe-from-success (File.open-with &(str* name ".ppm") "wb+"))
          hw (/ w 2)
          hh (/ h 2)]
      (do
        (ignore (File.write &f &(fmt "P3\n%d %d\n255\n" w h)))
        (for [y hh (neg hh) -1]
          (for [x (neg hw) hw]
            (let-do [d (canvas-to-viewport x y w h)
                     c (trace-ray scene &o &d 1.0 inf)]
              (ignore
                (File.write &f
                  &(fmt "%d %d %d\n"
                    (Int.min 255 (Color.red &c))
                    (Int.min 255 (Color.green &c))
                    (Int.min 255 (Color.blue &c)))))
              )))
        (File.close f))))
)
